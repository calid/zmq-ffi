#
# Module Generated by Template::Tiny on [% date %]
#

package ZMQ::FFI::[% zmqver %]::Socket;

use FFI::Platypus;
use FFI::Platypus::Buffer;
use FFI::Platypus::Memory qw(malloc free memcpy);

use Carp qw(croak carp);
use Try::Tiny;

use ZMQ::FFI::[% zmqver %]::Raw;
use ZMQ::FFI::Custom::Raw;
use ZMQ::FFI::Constants qw(:all);
use ZMQ::FFI::Util qw(current_tid);
[% lib_imports %]
use Moo;
use namespace::clean;

no if $] >= 5.018, warnings => "experimental";
use feature 'switch';

with qw(
    ZMQ::FFI::SocketRole
    ZMQ::FFI::ErrorHelper
    ZMQ::FFI::Versioner
);

my $FFI_LOADED;

sub BUILD {
    my ($self) = @_;

    unless ($FFI_LOADED) {
        ZMQ::FFI::Custom::Raw::load($self->soname);
        ZMQ::FFI::[% zmqver %]::Raw::load($self->soname);
        $FFI_LOADED = 1;
    }

    # force init zmq_msg_t
    $self->_zmq_msg_t;

    # ensure clean edge state
    while ( $self->has_pollin ) {
        $self->recv();
    }

    # set default linger
    $self->set_linger(0);
}

[% FOREACH method IN api_methods %]
[%- [%- method -%] -%]
[% END %]

sub DEMOLISH {
    my ($self) = @_;

    return if $self->socket_ptr == -1;

    $self->close();
}

1;

# vim:ft=perl
